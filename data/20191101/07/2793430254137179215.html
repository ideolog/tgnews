<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8"/>
    <meta property="og:url" content="https://habr.com/en/company/microsoft/blog/473142/"/>
    <meta property="og:site_name" content="Habr"/>
    <meta property="article:published_time" content="2019-11-01T07:00:02+00:00"/>
    <meta property="og:title" content="Upcoming SameSite Cookie Changes in ASP.NET and ASP.NET Core"/>
    <meta property="og:description" content="SameSite is a 2016 extension to HTTP cookies intended to mitigate cross site request forgery (CSRF). The original design was an opt-in feature which could be u..."/>
  </head>
  <body>
    <article>
      <h1>Upcoming SameSite Cookie Changes in ASP.NET and ASP.NET Core</h1>
      <address><time datetime="2019-11-01T07:00:02+00:00">01 Nov 2019, 07:00</time> by <a rel="author" href="https://habr.com/en/users/msgeek/" target="_blank">msgeek</a></address>
      <p>SameSite is a 2016 <a href="https://tools.ietf.org/html/draft-west-first-party-cookies-07#section-4.1">extension to HTTP cookies</a> intended to mitigate cross site request forgery (CSRF). The original design was an opt-in feature which could be used by adding a new SameSite property to cookies. It had two values, Lax and Strict. <br/><br/>Setting the value to Lax indicated the cookie should be sent on navigation within the same site, or through GET navigation to your site from other sites. A value of Strict limited the cookie to requests which only originated from the same site. Not setting the property at all placed no restrictions on how the cookie flowed in requests. OpenIdConnect authentication operations (e.g. login, logout), and other features that send POST requests from an external site to the site requesting the operation, can use cookies for correlation and/or CSRF protection. These operations would need to opt-out of SameSite, by not setting the property at all, to ensure these cookies will be sent during their specialized request flows.<br/><br/>Google is now <a href="https://tools.ietf.org/html/draft-west-cookie-incrementalism-00">updating the standard</a> and implementing their proposed changes in an upcoming version of Chrome. The change adds a new SameSite value, «None», and changes the default behavior to «Lax». This breaks OpenIdConnect logins, and potentially other features your web site may rely on, these features will have to use cookies whose SameSite property is set to a value of «None». <br/><br/>However browsers which adhere to the original standard and are unaware of the new value have a different behavior to browsers which use the new standard as the SameSite standard states that if a browser sees a value for SameSite it does not understand it should treat that value as «Strict». This means your .NET website will now have to add user agent sniffing to decide whether you send the new None value, or not send the attribute at all.</p>
      <figure>
        <img src="https://habrastorage.org/webt/k2/2l/7q/k22l7q1la86bjehti0k8zzmdmru.jpeg"/>
      </figure>
      <p>.NET will issue updates to change the behavior of its SameSite attribute behavior in .NET 4.7.2 and in .NET Core 2.1 and above to reflect Google’s introduction of a new value. The updates for the .NET Framework will be available on November 19th as an optional update via Microsoft Update and WSUS if you use the «Check for Update» functionality. On December 10th it will become widely available and appear in Microsoft Update without you having to specifically check for updates. .NET Core updates will be available with .NET Core 3.1 starting with preview 1, in November.<br/><br/>.NET Core 3.1 will contain an <a href="https://github.com/aspnet/Announcements/issues/390">updated enum definition</a>, SameSite.Unspecified which will not set the SameSite property.<br/><br/>The OpenIdConnect middleware for Microsoft.Owin v4.1 and .NET Core will be updated at the same time as their .NET Framework and .NET updates, however we cannot introduce the user agent sniffing code into the framework, this must be implemented in your site code. The implementation of agent sniffing will vary according to what version of ASP.NET or ASP.NET Core you are using and the browsers you wish to support.<br/><br/>For ASP.NET 4.7.2 with Microsoft.Owin 4.1.0 agent sniffing can be implemented using <a href="https://docs.microsoft.com/en-us/previous-versions/aspnet/dn800238(v%3Dvs.113)">ICookieManager</a>;</p>
      <pre>public class SameSiteCookieManager : ICookieManager<br/>{<br/>  private readonly ICookieManager _innerManager;<br/><br/>  public SameSiteCookieManager() : this(new CookieManager())<br/>  {<br/>  }<br/><br/>  public SameSiteCookieManager(ICookieManager innerManager)<br/>  {<br/>    _innerManager = innerManager;<br/>  }<br/><br/>  public void AppendResponseCookie(IOwinContext context, string key, string value,<br/>                                   CookieOptions options)<br/>  {<br/>    CheckSameSite(context, options);<br/>    _innerManager.AppendResponseCookie(context, key, value, options);<br/>  }<br/><br/>  public void DeleteCookie(IOwinContext context, string key, CookieOptions options)<br/>  {<br/>    CheckSameSite(context, options);<br/>    _innerManager.DeleteCookie(context, key, options);<br/>  }<br/><br/>  public string GetRequestCookie(IOwinContext context, string key)<br/>  {<br/>    return _innerManager.GetRequestCookie(context, key);<br/>  }<br/><br/>  private void CheckSameSite(IOwinContext context, CookieOptions options)<br/>  {<br/>    if (DisallowsSameSiteNone(context) &amp;&amp; options.SameSite == SameSiteMode.None)<br/>    {<br/>        options.SameSite = null;<br/>    }<br/>  }<br/><br/>  public static bool DisallowsSameSiteNone(IOwinContext context)<br/>  {<br/>    // TODO: Use your User Agent library of choice here.<br/>    var userAgent = context.Request.Headers["User-Agent"];<br/>    return userAgent.Contains("BrokenUserAgent") ||<br/>           userAgent.Contains("BrokenUserAgent2")<br/>  }<br/>}</pre>
      <p>And then configure OpenIdConnect settings to use the new CookieManager;</p>
      <pre>app.UseOpenIdConnectAuthentication(<br/>    new OpenIdConnectAuthenticationOptions<br/>    {<br/>    // … Your preexisting options … <br/>    CookieManager = new SameSiteCookieManager(new SystemWebCookieManager())<br/>});</pre>
      <p>SystemWebCookieManager will need the .NET 4.7.2 or later SameSite patch installed to work correctly.<br/><br/>For ASP.NET Core you should install the patches and then implement the agent sniffing code within a <a href="https://docs.microsoft.com/en-us/aspnet/core/security/authentication/cookie?view=aspnetcore-3.0#cookie-policy-middleware">cookie policy</a>. For versions prior to 3.1 replace SameSiteMode.Unspecified with (SameSiteMode)(-1).</p>
      <pre>private void CheckSameSite(HttpContext httpContext, CookieOptions options)<br/>{<br/>    if (options.SameSite &gt; SameSiteMode.Unspecified)<br/>    {<br/>        var userAgent = httpContext.Request.Headers["User-Agent"].ToString();<br/>        // TODO: Use your User Agent library of choice here.<br/>        if (/* UserAgent doesn’t support new behavior */)<br/>        {<br/>               // For .NET Core &lt; 3.1 set SameSite = -1<br/>               options.SameSite = SameSiteMode.Unspecified;<br/>         }<br/>    }<br/>}<br/><br/>public void ConfigureServices(IServiceCollection services)<br/>{<br/>    services.Configure&lt;CookiePolicyOptions&gt;(options =&gt;<br/>    {<br/>        options.MinimumSameSitePolicy = SameSiteMode.Unspecified;<br/>        options.OnAppendCookie = cookieContext =&gt; <br/>            CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);<br/>        options.OnDeleteCookie = cookieContext =&gt; <br/>            CheckSameSite(cookieContext.Context, cookieContext.CookieOptions);<br/>    });<br/>}<br/><br/>public void Configure(IApplicationBuilder app)<br/>{<br/>    app.UseCookiePolicy(); // Before UseAuthentication or anything else that writes cookies.<br/>    app.UseAuthentication();<br/>    // …<br/>}</pre>
      <p>Under testing with the Azure Active Directory team we have found the following checks work for all the common user agents that Azure Active Directory sees that don’t understand the new value.</p>
      <pre>public static bool DisallowsSameSiteNone(string userAgent)<br/>{<br/>    // Cover all iOS based browsers here. This includes:<br/>    // - Safari on iOS 12 for iPhone, iPod Touch, iPad<br/>    // - WkWebview on iOS 12 for iPhone, iPod Touch, iPad<br/>    // - Chrome on iOS 12 for iPhone, iPod Touch, iPad<br/>    // All of which are broken by SameSite=None, because they use the iOS networking stack<br/>    if (userAgent.Contains("CPU iPhone OS 12") || userAgent.Contains("iPad; CPU OS 12"))<br/>    {<br/>        return true;<br/>    }<br/><br/>    // Cover Mac OS X based browsers that use the Mac OS networking stack. This includes:<br/>    // - Safari on Mac OS X.<br/>    // This does not include:<br/>    // - Chrome on Mac OS X<br/>    // Because they do not use the Mac OS networking stack.<br/>    if (userAgent.Contains("Macintosh; Intel Mac OS X 10_14") &amp;&amp; <br/>        userAgent.Contains("Version/") &amp;&amp; userAgent.Contains("Safari"))<br/>    {<br/>        return true;<br/>    }<br/><br/>    // Cover Chrome 50-69, because some versions are broken by SameSite=None, <br/>    // and none in this range require it.<br/>    // Note: this covers some pre-Chromium Edge versions, <br/>    // but pre-Chromium Edge does not require SameSite=None.<br/>    if (userAgent.Contains("Chrome/5") || userAgent.Contains("Chrome/6"))<br/>    {<br/>        return true;<br/>    }<br/><br/>    return false;<br/>}</pre>
      <p>This browser list is by no means canonical and you should validate that the common browsers and other user agents your system supports behave as expected once the update is in place.<br/><br/>Chrome 80 is scheduled to <a href="https://www.chromium.org/updates/same-site">turn on the new behavior</a> in February or March 2020, including a temporary mitigation added in Chrome 79 Beta. If you want to test the new behavior without the mitigation use Chromium 76. Older versions of Chromium are <a href="http://www.chromium.org/getting-involved/download-chromium">available for download</a>.<br/><br/>If you cannot update your framework versions by the time Chrome turns the new behavior in early 2020 you may be able to change your OpenIdConnect flow to a Code flow, rather than the default implicit flow that ASP.NET and ASP.NET Core uses, but this should be viewed as a temporary measure.</p>
      <ul>
        <li>For ASP.NET MVC and Microsoft.Owin support you can use the Katana GitHub repository at <a href="https://github.com/aspnet/AspNetKatana">https://github.com/aspnet/AspNetKatana</a>.</li>
        <li>For ASP.NET Core support you can use the ASP.NET Core GitHub repository at <a href="https://github.com/aspnet/AspNetCore">https://github.com/aspnet/AspNetCore</a>.</li>
        <li>For .NET Framework support please see <a href="https://dotnet.microsoft.com/platform/support/policy/dotnet-framework">https://dotnet.microsoft.com/platform/support/policy/dotnet-framework</a></li>
      </ul>
      <p>We strongly encourage you to download the updated .NET Framework and .NET Core versions when they become available in November and start planning your update before Chrome’s changes are rolled out.</p>
      <related>
        <h4>Similar posts</h4>
        <a href="https://habr.com/en/post/446508/"/>
        <a href="https://habr.com/en/post/444010/"/>
        <a href="https://habr.com/en/post/436732/"/>
      </related>
    </article>
  </body>
</html>